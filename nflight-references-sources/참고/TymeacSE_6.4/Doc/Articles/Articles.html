<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Framework Details</title>

<meta name="Microsoft Border" content="b, default">
</head>

<body background="../Brochure/Images/wheat.jpg"><!--msnavigation--><table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">

<h1 align="center">Product Articles</h1>

<p align="center">&nbsp;</p>

<blockquote>
  <blockquote>
    <p><strong><a href="ForkJoinArticle.html">Fork-Join Development in Java SE</a></strong></p>
    <blockquote>
      <p>&nbsp;Forking or splitting the workload into multiple tasks for 
      parallel processing and joining the results together is a technique used 
      in countless scientific, number crunching applications. Many other 
      applications could benefit from fork-join processing but using the 
      scientific approach may not be in their best interest.</p>
      <p>This article presents an “embarrassingly parallel” fork-join approach 
      that works well for everyday applications in Java SE / ME. </p>
    </blockquote>
    <p><strong><a href="PriQueArticle.html">High Performance Priority Queues in 
    Java SE</a></strong></p>
    <blockquote>
      <p>The priority queue is one of the oldest structures in modern computer 
      software. Both operating systems and applications use priority queues to 
      organize the order of operations. Many crucial user applications require 
      high performance priority queues but genuinely high performance priority 
      queues are not readily available in Java SE.</p>
      <p>This article presents a high performance option using Wait Lists for 
      Java SE as an alternative to maps, trees, heaps and skip lists. </p>
    </blockquote>
    <p><strong><a href="J2SEArticle.html">Managing Threads in Java SE</a></strong></p>
    <blockquote>
      <p>Since the dawn of third-generation computers, legions of successful 
      multi-threading applications have run inside containers. Because there is 
      no way to control a thread of execution at the operating system level, 
      knowledgeable developers have built containers to house the elusive 
      threads at the application level.</p>
      <p>This article expounds Open Source Tymeac, a container for managing Java 
      SE application threads. </p>
    </blockquote>
    <p><strong><a href="ConquerArticle.html">A Java Fork-Join Conqueror</a></strong></p>
    <blockquote>
      <p>Fork-Join processing using the compute intensive methodology of 
      Divide-and-Conquer.</p>
    </blockquote>
    <p><strong><a href="AndroidArticle.html">Managing Threads in Android</a></strong></p>
    <blockquote>
      <p>Fork-Join processing using the Android environment.</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>&nbsp;</p>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>

<p><b><small><font size="2">© 1998 - 2012 Cooperative Software Systems, Inc.&nbsp; All rights 
    reserved.</font></small></b></p>

</td></tr><!--msnavigation--></table></body></html>